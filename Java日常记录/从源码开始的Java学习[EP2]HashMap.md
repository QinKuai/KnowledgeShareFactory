## 从源码开始的Java学习[EP1]HashMap

### 一. 前言

- 通过这个系列督促自己通过学习Java源码，增长自己的编码能力和对Java编程设计的理解。有相似想法的人可以以此为参考，但最好还是直接去学习Java源码为最好。
- 顺带一提，博主只是刚入Java栈的菜鸟一只，以下都是自己的理解和思考，希望有错误和疏漏的地方大家轻喷，能给我指出具体哪里有问题自然是最好，大家一起交流。



### 二. 正片

#### 1. HashMap的基本

- Hash，也叫哈希、散列，是把任意长度的key值通过散列算法变化成固定长度的key值。

- Node内部静态类，实现了Map接口中的Entry接口，内部包含四种属性

```java
// jdk8源码
static class Node<K,V> implements Map.Entry<K,V> {
    final int hash;
    final K key;
    V value;
    Node<K,V> next;
    
    // ...
}
```

- HashMap的数组长度始终是2的指数倍，如16，32等等。
- HashMap的基本底层数据结构，**数组+单链表（也可以称为散列表）**
  - **数组：根据key的hash值决定该Node的数组索引（在hash后还会&上数组长度-1来获取数组索引）。**
  - **单链表：由于hash算法以及之后的&操作可能导致索引相同，链表解决相同数组索引的node的存放。**
- HashMap在获取数组索引时，使用的hash(key) & (length - 1)这种做法实际上就是在作取余操作，因为数组长度是2的指数倍，减一后二进制码后面的位数就全是1了。
  - **这样做既达到了取余的目的，同时由于使用了&操作直接操作二进制码，提升了效率。**



#### 2. JDK变化带来的HashMap变化

- 其一，**jdk8以前的HashMap使用的链表头插法，jdk8后的HashMap使用的链表尾插法**。
  - 这样更改的理由是？
  - **老版本的HashMap采用的头插法是因为只采用了链表作存储，而新版本的HashMap由于红黑树的加入，需要遍历链表，因此采用尾插法**。

- 其二，hash算法的简化（指HashMap中的静态hash方法，使用到了key对应类重写的hashcode方法）
- 其三，resize逻辑更改。
- 其四，jdk8采用了红黑树增强增删改查的效率。



#### 3. 为什么说HashMap不能并发？

- JDK8以前
  - 这个时候的HashMap，采用的是数组+链表，链表节点的插入方式是头插法。
  - **会带来get死循环的点来自于HashMap的扩容重哈希的代码**。
  - 简单来说就是当线程1执行完了获取next节点的代码后，转到线程2执行，并且线程2正常执行结束，然后线程1苏醒，继续执行，最后就会形成环形链表。
  - 这里最核心的点是
    - 线程1获取到了next节点，这个节点值实际上就是和线程2正常结束后的结果产生环形链表的核心。
    - 线程会有自己的临时内存空间，也就是说扩容的table在两个线程中都有自己的副本，但节点没有，因此线程1苏醒后运行时读到的节点next信息是线程2执行成功后的。
  - 具体环形列表形成过程可以参考https://blog.csdn.net/zhuqiuhui/article/details/51849692
- JDK8之后
  - 通过尾插法解决了环形链表的问题。
  - 但由于内存的不可见性，也就是之前说的线程的独立内存空间，同样会导致数据覆盖和数据不同步的问题。



#### 4. JDK8的红黑树

- 红黑树，是一种特化的平衡二叉树





