## Redis进阶

### 1. Redis进阶知识

#### 1.1 Redis.conf 配置文件

- 配置文件中包含了几乎所有的Redis功能配置，包括**基本、网络、持久化（rdb、aof）、内存、集群等配置**。

- 网络信息配置

```bash
# 配置Redis服务端地址
bind 127.0.0.1
# 配置Redis服务端端口
port 6379
# 开启保护模式，默认为yes
# 当需要其他主机连接时，可以配置为no
protected-mode yes
```

- 一般常用配置

```bash
# 以守护进程的方式运行
# 默认关闭，为no
# 当需要自己开启时，改为yes
daemonize yes

# 如果以守护进程方式运行
# 需要指定pid进程文件
pidfile /var/run/redis_6379.pid

# 日志
# 一共四个级别
# debug > verbose > notice（生产环境常用） > warning
loglevel notice

# 日志文件名
# 指定为空字符串则为标准输出
# 否则根据指定的文件地址生成日志文件
logfile ""

# 数据库数量
databases 16
```

- 快照配置（持久化相关，表示在规定的时间内，执行了多少操作，则会持久化到文件）

```bash
# 快照配置信息
# save seconds changes
## 900s内至少有1次change，则持久化
save 900 1
## 300s内至少有10次change，则持久化
save 300 10
## 60s内至少有10k次change，则持久化
save 60 10000

# 持久化如果出错，Redis是否需要继续工作
# 默认且一般都是开启的
stop-writes-on-bgsave-error yes

# 是否压缩rdb文件（压缩需要消耗CPU资源）
# 默认开启
rdbcompression yes
# 保存rdb文件时，进行文件CRC64校验（需要消耗CPU资源）
# 默认开启
rdbchecksum yes
# 配置rdb文件名
dbfilename dump.rdb
# 配置rdb文件所在的目录
dir ./
```

- 客户端连接设置

```bash
# 同时可连接Redis服务端的客户端数量
# 默认为10000
maxclients 10000
```

- 内存配置

```bash
# 配置最大的内存容量，默认单位为字节
maxmemory <bytes>
# 内存达到上限的处理策略
# volatile-lru 只对设置了过期时间的key执行LRU
# allkeys-lru 对所有key执行LRU
# volatile-random 随机删除即将过期的key
# allkeys-random 随机删除
# volatile-ttl 删除即将过期的
# 默认如下，永不过期，报错
maxmemory-policy noeviction
```

- APPEND ONLY模式，即aof配置（持久化方面）

```bash
# 默认不开启aof模式
# 默认是使用rdb方式进行持久化
# 大部分情况下，rdb持久化模式完全够用
appendonly no
# aof持久化文件名
appendfilename "appendonly.aof"
# 同步配置
# 默认为每一秒同步一次
# always 每次修改都sync
# no 不执行sync，使用操作系统自己同步数据
appendfsync everysec 
```



#### 1.2 持久化

- Redis作为内存数据库，数据断电即失，因此持久化很重要。

##### 1.2.1 rdb(redis database)模式

- **Redis默认持久化方式采用的是rdb，默认文件名为dump.rdb**。
- rdb的工作模式，直白点说就是快照：
  - **Redis会单独创建一个子进程，将所有数据写入到一个临时的rdb文件中，写入完成后将替换掉原来的正式rdb文件，完成一次持久化操作**。
  - **该子进程来自于Redis服务端父进程，读取共享内存块获取数据，而父进程并不会产生任何的IO操作**。
- rdb模式非常高效，但同样有问题，**当在写入临时rdb文件还没有完成时断电，会导致该次数据丢失**。
- **优势**
  - **适合大规模数据的恢复**
  - **对数据的完整性要求不高（因为有丢数据的风险）**
- **劣势**
  - **有一定的时间间隔（数据丢失问题）**
  - **fork子进程需要内存空间**



##### 1.2.2 aof(append only file)模式

- aof模式，将**所有执行的写操作**记录（读操作不记录）下来，类似于log。Redis重启时重新读取该文件并构建数据。**也就是需要重新花时间执行一遍所有操作**。
- aof也存在断电丢失的问题，但可以通过秒级限制、每条命令都备份等方式，降低损失数据量。
- 优势
  - aof配置每一次修改都同步，数据损失很低。
  - aof配置默认每一秒开启一次，可能会丢失一秒的数据。
  - aof配置从不同步，效率最高。
- 劣势
  - aof的数据文件要比rdb数据文件大很多（如实记录了所有写操作命令）
  - Redis加载aof文件比rdb慢很多（需要重新执行所有aof文件中的命令）



#### 1.3 发布订阅

- Redis发布订阅(publish/subscribe)是一种消息通信模式，发送者(pub)发送信息，订阅者(sub)接收信息。
- 能实现，但暂不理解Redis的发布订阅如何在实际场景中使用。
- **更复杂的场景还是使用MQ为优**。



#### 1.4 主从复制

- 将一台Redis服务器上的数据，复制到其他Redis服务器上。前者称为主节点master，后者称为从节点slave。
- **数据复制是单向的，只能从主节点到从节点。master以写为主、slave以读为主**。
- **主从复制是为了实现读写分离的方案，也是实现集群的基础**。
- 主从复制的作用：
  - **数据冗余**，提供了一种数据热备份方案，是持久化以外的一种数据冗余方式。
  - **故障恢复**，当主节点出现问题，可以通过从节点提供服务。
  - **负载均衡**，通过读写分离，通过多个节点负担读负担，提升Redis服务器的并发量。
- 配置方式
  - 只配置从节点，不用配置主节点，Redis服务器默认自己就是主节点。
  - **通过`info replication`查看当前节点的主从情况**。
  - **在从机中输入命令`slaveof ip port`，就能连接主机**。
  - 永久的主从配置，在配置文件中配置
    - replicaof masterip masterport，配置主机ip和端口。
    - masterauth master-password，如果主机有密码，则需要给定密码。

- 主从复制体现点
  - **主机能读写，从机只能读**。
  - 默认配置
    - 主机宕机后，从机依旧保持为从机。
    - 但从机宕机后，如果是非配置文件配置，则会丢失从机信息，直到重新配置好从机信息（从机配置好后会同步一次主机数据），从机才会与主机数据保持同步。
  - 全量复制，从机第一次连接到主机，或是断开重连时，会将数据文件全部加载进内存。
  - 增量复制，主机每次写入都会增量同步到从机中。
- 主机宕机，从机变主机
  - 通过手动配置从机变主机，`slaveof no one`将从机切换到主机。

- **哨兵模式**

  - 主机宕机，自动切换主机，是Redis集群中最常用的模式。

  - **哨兵本身是一个独立运行的进程，通过发送命令，等待Redis服务器响应，从而实现监控效果**。

  - 哨兵作用

    - **通过发送命令，起到监控服务器及其运行状态，包括主从机**。
    - **当哨兵监控到主机宕机，会自动将某一从机切换为主机，然后通过发布订阅模式通知其他从机切换主机**。

  - **业务场景下，哨兵进程也不会只有一个**。

    - 在多哨兵的场景下，不会因为单一哨兵检测到主机宕机就进行主机切换，会根据一定数量的哨兵同时检测到（类似于投票制度），才会启动主机切换。

  - 配置方式

    - 创建哨兵配置文件，`sentinel.conf`配置文件，也可以在redis安装包中找到文件，也可以自己写。
    - 最核心的一句配置语句为`sentinel monitor mymaster 127.0.0.1 1`，其他配置可以通过上述文件查看。
    - 然后通过`redis-sentinel sentinel.conf`开启进程。

  - 优势&劣势

    - 哨兵集群基于主从复制，同时实现了主从的自动切换，提升系统的可用性。

    - 但这种情况下的集群不好实现在线扩容，同时哨兵本身的配置也很麻烦（有很多配置项）。





#### 1.5 缓存穿透、击穿与雪崩

- 