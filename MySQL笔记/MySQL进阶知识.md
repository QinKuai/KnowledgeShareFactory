## MySQL进阶知识

### 1. 分层与存储引擎

#### 1.1 分层

- MySQL逻辑分层：**连接层 - 服务层 - 引擎层 - 存储层**

#### 1.2 引擎

- 可以通过`show engines` 查看MySQL的支持的引擎情况，可以通过`show variables like '%engine%'`查看MySQL默认使用的表引擎情况。
- 常用引擎如下：

- `InnoDB`（默认）：事务优先，行级锁，外键
- `MyISAM`：性能优先，表级锁





### 2. 索引

- **索引是一种数据结构，旨在加快数据的查询效率**。
- 在原有数据之外，DBS还维护着一种**满足特定查找算法的数据结构，这类数据结构以某种形式指向数据**。

#### 2.1 基本

- **索引能影响where和order by，也即查找和排序时的效率**。
- 索引本身也很大，因此会通过索引文件的形式放在磁盘上。
- 索引在未指名的情况下都指**B树（多路搜索树）索引**，还有Hash索引等。
- 索引的优势：提高查找效率，降低磁盘IO和CPU消耗。
- 索引的劣势：索引本身需要占据磁盘空间，每次写时都还需更新索引文件，索引需要不断优化找出最优索引。

#### 2.2 类型

- **一张表中最多建立5个索引为最优**。

- 单值索引：一个索引只包含单列，一张表中能有多个单列索引。
- 唯一索引：索引值必须是唯一，允许有空值（每行的值必须唯一）。
- 复合索引：一个索引包含多个列。

#### 2.3 基本语法

```mysql
# 创建索引
## 单值索引
create index indexName on tableName(colName);
## 唯一索引
create unique index indexName on tableName(colName);
## 复合索引
create index indexName on tableName(colName1, colName2); 

# 另一种创建索引
alter tableName add [unique] index [indexName] on tableName(colName);

# 删除索引
drop index [indexName] on tableName;

# 查看索引
show index from tableName \G
```

#### 2.4 BTree索引

- **在数据总量特别巨大时，不可能将所有数据同时拉入内存中处理，这时就必须使用到文件系统，也就意味着磁盘IO的出现。磁盘IO的效率相较访问内存的速度是差很多的，因此需要尽可能降低磁盘IO的次数，以提高效率**。
- 对于原有定义的树结构，每一个节点都只包含一个数据。数据量大的情况下，树要么度非常高、要么深度非常高、甚至两者同时很高。
- **多路查找树，其中每一个节点的孩子节点数可以多于两个，且每个节点可以存储多个元素，所有的叶子节点都位于同一深度**。

- **B树是一种平衡多路查找树**，2-3树等都是B树的特例，节点最大的孩子数目称为B树的阶。例如2-3树为3阶B树。
- 对于m阶的B树，
  - 每一个非根节点都有k-1个元素和k个孩子；
  - 每一个叶子节点都有k-1个元素
  - 向上取整(m/2) <= k <= m。

- 为什么B树能减少硬盘访问次数，提升访问效率呢？
  - 对于外存，例如硬盘，是将所有信息分割成了相等大小的页，每次硬盘读写都是一个或多个完整的页。
  - **将B树的阶与硬盘规定的页大小做匹配，例如一棵B树的阶为1001（即一个节点中包含的元素为1000个），高度为2，在这颗B树上寻找某一关键词就只需要访问硬盘两次即可**。

- B+树在查找上相似于B树，但在遍历所有元素上做了调整，在叶子节点上列出了根节点和分支节点中的元素，并建立了叶子节点之间的单链表，简化中序遍历B+树的过程。
- **B+树的所有数据全在叶子节点，即使在分支节点或根节点查到了数据，依旧需要到达包含该数据的叶子节点才完成了实际的访问**。

#### 2.5 索引何时建立

- 在一个字段中，数据越不重复，索引的效率会越高。

- 何时建立
  - **主键自动建立唯一索引；**
  - **频繁作为查询条件的字段应当创建索引；**
  - **查询中与其他表关联的字段，外键关系建立索引；**
  - **在单值索引和复合索引中，倾向于复合索引；**
  - **查询中排序的字段，通过索引能加速排序速度；**
  - **查询中统计或分组字段(group by也和索引相关)。**
- 何时不建立
  - **表记录太少（3M+条左右数据）；**
  - **频繁更新的字段不适合创建索引；**
  - **where条件里用不到的条件不用创建索引；**
  - **一个数据列中包含了太多的重复列，例如用户的性别。**

#### 2.6 性能分析

- MySQL查询优化器，会将输入的SQL进行MySQL认为的优化策略，然后再执行优化后的SQL操作
- 服务器硬件瓶颈可以通过：top查看性能状态
  - CPU：CPU饱和一般发生在**数据大量放入内存或从磁盘读取数据时**
  - IO：磁盘IO瓶颈发生在**装入数据远大于内存时**
  - Linux配置不匹配

#### 2.7 explain

##### 2.7.1 explain关键字

- **使用explain关键字能模拟优化器执行SQL过程，从而知晓SQL在MySQL中的执行过程，进而分析查询语句或者表结构的性能问题**。
- 将explain放在将要执行的SQL前面，执行后就能查看输出信息。

##### 2.7.2 explain会指出什么

- **表的读取顺序**，对应id
- **数据读取操作的操作类型**，对应type
- **哪些索引可以使用**，对应possible_key
- **哪些索引被实际上使用**，对应key
- **表之间的引用**，对应ref
- **每张表有多少行被优化器查询**，对应rows

##### 2.7.3 explain中的字段

- ***id***，表的读取加载顺序
  - id相同，执行顺序由上至下
  - id不同，id序号会增加，id越大优先级越高，越先被执行
- **select_type**，查询类型
  - SIMPLE，查询中不包含子查询或是union
  - PRIMARY，查询中包含复合查询，最外层标记为primary
  - SUBQUERY，在select或where中包含了子查询语句
  - DERIVED，from中包含的子查询标记为derived，意味着临时表
  - UNION，若第二个select出现在union之后，则被标记为union；若union包含在from的子查询中，则外层select被标记为derived
  - UNION RESULT，从union结果中合并出结果
- **table**，来源于那张表
- ***type***，访问类型
  - **性能最好到最差：system>const>eq_ref>ref>range>index>ALL，一般来说查询至少保证range，最好能到ref**。
  - ALL，全表扫描
  - **index，全索引扫描，遍历索引树，例如遍历整个建了索引的列**
  - **range，只检索给定范围的行，使用一个索引来选择行，key显示使用了哪个索引，一般出现在where中的between、<、>、in等情况**
  - **ref，非唯一性索引扫描，返回匹配某个值的所有行，一对多关系**
  - eq_ref，唯一性索引扫描，对于索引列中的每一个值，表中只有一条记录与之匹配，类似于const类型，但并没有给定某个值
  - const，索引一次就能找到，常见于unique或是主键等唯一索引的情况，并且在where子句中给定唯一列的某个值时
  - system，表里只有一条记录（等于系统表），是const类型的特例
  - NULL
- **possible_keys**，可能用到的索引
  - **显示可能应用到的索引，查询对应字段涉及到的索引都会列出，但不一定会实际使用**。
- ***key***，实际用到的索引
  - NULL为未使用索引，查询中若使用了覆盖索引则出现在key列表中
- **key_len**，索引中使用到的长度
  - 在不损失精度的情况下，长度越短越好。
  - 显示为索引字段的最大可能长度，并非实际使用长度
  - key_len是根据表定义计算而得，并非通过表内检索得到
- **ref**，显示索引的哪一列被使用了
  - 如果可能的话，是一个常数
  - 哪些列或常量被用于查找索引列上的值
  - 例如使用到外键的情况，就会显示外键的具体位置；使用列等于一个常量时，则会出现const
- ***rows***，找到所需记录需要读取的行数
  - 根据表统计信息以及索引使用情况，找到所需记录需要读取的行数。
- ***Extra***，不在其他列显示但依旧很重要的信息
  - **Using filesort**，文件内排序，MySQL无法使用建立好的索引，需要在外部建立新的索引提供排序，较为危险。（索引使用满足最左匹配原则为最优）
  - **Using temporary**，使用了临时表保存中间结果，MySQL在查询结果排序时使用了临时表。常见于order by和group by，group by较频繁。
  - **Using index**，表明select操作使用了**覆盖索引**。
    - **覆盖索引，select中的数据列是索引建立时的数据列的子集，即不需要通过索引读取数据文件便能获取到select需要的数据**。
    - 如果同时出现using where，则表明索引被用来执行索引键值的查找
    - 如果没有同时出现using where，则表明索引只是读取了数据，而非执行了查找动作。
  - Using where，使用了where子句
  - Using join buffer，表join时使用了连接缓存，配置文件中的joinbuffer可以调大
  - Impossible where，where子句总是不能获取到数据

#### 2.8 索引优化

- **范围条件（>,<, in, between等）会导致后续索引失效，这时推荐在复合索引中将会涉及到范围的列删掉，只以给定值和需要排序、分组的列建立索引**。

- **左连接左表必定全表扫描，因此索引最好是建在右表中。同理于右连接，加左表。永远使用小结果集驱动大结果集，也就是说将必定全表扫描的表设置为小表**。
- **where中的and条件顺序且都*为常量相等*时，并不影响索引的使用，因为存在查询优化器**。
  - order by的顺序同样需要满足最佳左前缀，从and条件中结束后的列开始（可以等于该列），最后到索引列结束为止，不然就会出using filesort。
  - group by分组前必排序，因此类似于order by，如果不满足索引规则，则会出现using temporary

#### 2.9 索引失效

- **复合索引使用顺序错误（最佳左前缀，从最左开始，且中间不能跳过），导致索引失效**。
- **不在索引列上做任何操作（计算、函数、自动或手动类型转化），导致索引失效而转向全表扫描**。

- **范围条件（>,<, in, between等）会导致后续索引失效，这时推荐在复合索引中将会涉及到范围的列删掉，只以给定值和需要排序、分组的列建立索引**。
- **尽量使用覆盖索引，直接查询索引列，少用select ***。
- **在使用不等于(<>，!=)时，会导致索引失效而全边扫描**。

- **like以通配符开头('%a')，会导致索引失效，使用右边能避免索引失效，达到range的效果**。
  - **通过使用覆盖索引机制，能将左%的情况从ALL降低到index级别**
- **字符串不加‘’会导致索引失效，隐式数据转换会导致索引失效**。
- **少用or，会导致索引降级为range**。



### 3. SQL优化

- 性能低、执行时间长、等待时间长、SQL语句欠佳（尤其是联结时）、索引失效、服务器参数设置不合理（缓存、线程数）
- 基本调优逻辑
  - **系统运行一天，找到慢SQL情况**
  - **开启慢查询日志，设于阈值，并将慢SQL抓取出来**
  - **explain+慢SQL分析**
  - **show profile**
  - **数据库服务器参数调优**

#### 3.1 explain

- 使用explain关键词查看索引使用情况，并找到优化策略。

#### 3.2 查询截取分析

##### 3.2.1 永远小表驱动大表

- in和exists的区别
  - select * from A where id in (select id from B);
  - 上述语句适用于B为小表，A为大表的情况。
  - select * from A where exists (select 1 from B where B.id = A.id)
  - 上述语句适用于A为小表，B为大表的情况。
  - exists只根据外部给定的值返回true或是false（其中的select表单不会被解析，可以任意给出），而in是要实实在在返回数据。

##### 3.2.2 order by排序优化

- 核心就是**使用index来排序，避免使用using filesort**（explain Extra字段）。
- **单路排序带来的缓存区大小问题**
  - 当查询的字段大小总和小于max_length_for_sort_data而且排序字段非Text或者blob类型时，MySQL会启用单路查询，否则就会使用多路查询。
  - **因为单路排序的策略问题，使用缓存区sort_buffer时过小，需要多次磁盘IO，获取数据，并还需要合并排序数据，会导致效率下降。**
- order by优化策略
  - **使用order by时不要使用select *，可能导致单路排序缓存问题。**
  - 增大数据库服务器sort_buffer_size和max_length_for_sort_data两个参数，前者提供更大的缓存区，但需要根据服务器能力考虑。后者是一个排序策略变更的阈值，小于这个阈值时会采用单路，否则就会多路查询。
- **order by能使用索引最佳左前缀，当列同时降序(desc)时，索引能正常工作(Backsward index scan)**。
- **如果where的条件中按照索引的最左前缀的列值为常量(col1 = value)，则order by能按照索引的最左前缀继续使用索引**。

##### 3.2.3 group by分组优化

- group by实质上就是先排序后分组，优化策略等同于order by。
- **唯一一点，能在where解决的问题就不要使用having**。

#### 3.3 慢查询日志

- 慢查询日志是MySQL提供的一种日志记录，用于记录在MySQL中响应时间超过了阈值的语句，阈值设置字段为long_query_time，默认10s。
- `show variables like 'long%'`能查看该值在MySQL中的值。
- **默认慢查询日志并没有开启，有需要时才打开，有一定的性能影响。**
- 慢查询日志情况
  - `show variables like 'slow%';`查看开启情况以及日志位置
  - `set global slow_query_log = 1;`对当前数据库开启慢查询日志，数据库重启后失效
  - 需要永久开启，需要使用MySQL配置文件my.inf(Linux)或者my.ini(Windows)。
  - `set gloabl long_query_time = 3`设置新的慢SQL时间阈值，这时需要重开数据库连接或者使用`show global variables like 'long%'`查看新值。
  - `show global status like '%slow_queries'`查看系统当前有多少慢SQL语句。
- 日志分析工具mysqldumpslow
  - 一般格式`mysqldumpslow [options] [log]`
  - 例如
    - `mysqldumpslow -s r -t 10 /var/lib/mysql/slow.log`返回结果集最多的10个SQL
    - `mysqldumpslow -s c -t 10 /var/lib/mysql/slow.log`返回访问次数最多的10个SQL
    - `mysqldumpslow -s t -t 10 -g "left join" /var/lib/mysql/slow.log`返回按时间排序且包含“left join”的10个SQL
  - 参数例子
    - -s，排序模式
      - r，返回记录降序
      - t，时间降序
      - c，访问次数降序
    - -t，返回数据量
    - -g，正则匹配且大小写不敏感

#### 3.4 show profile

- MySQL提供的用于分析当前会话中语句执行的资源消耗情况，用于测量SQL的调优。
- 默认关闭，并保存最近15次运行结果。
- 



### 4. 批量插入脚本

- 



### 5. 锁机制

#### 5.1 锁类型

- 

