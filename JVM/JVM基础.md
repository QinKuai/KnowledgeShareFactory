## JVM基础

### 1. 简述

- JVM是用于运行Java字节码的虚拟机，包括**一套字节码指令集、一组PC(Program Counter)寄存器、一个虚拟机栈、一个虚拟机堆、一个方法区和一个垃圾回收器**。
- **JVM运行在操作系统之上，不与硬件设备直接交互**。

#### 1.1 基本组成

- **类加载系统**
  - 负责从文件系统或是网络中加载Class信息，将加载完成的Class信息（Class类）放在**方法区**中。
- **方法区**
  - 存放最不常变动的信息，如类信息（Class类）、常量池（字符串常量、数字常量）。
- **堆**
  - 虚拟机启动时建立（一个JVM进程对应一个堆内存），是最主要的内存工作区域，**线程共享**。
- **栈**
  - 线程被创建时建立（每一个线程都对应一个栈），内部包含栈帧信息，**线程私有**。
- **直接内存**
  - Java的NIO库能使用直接内存，**该内存区域是在堆外，直接向系统申请的内存区域**，访问速度一般优于堆内存。
  - 大小不受堆内存大小设置的影响，但受到操作系统本身最大内存的影响。
- **垃圾回收系统**
  - Java的内存不能显式回收，都是交给JVM中的垃圾回收系统自动完成的。
  - 垃圾回收系统主要针对**方法区、堆内存、直接内存**等区域进行垃圾回收，栈内存不存在垃圾回收。
- **本地方法栈**
  - 本地方法栈类似于栈内存，该部分主要用于记录本地方法（native）的调用。本地方法底层通常是使用C/C++编写的。
- **PC寄存器**
  - **线程私有**，每一个线程会由JVM创建一个PC寄存器。
  - 在任意时刻，一个线程总是在执行一个方法，该方法被称为当前方法。如果当前方法非本地方法，PC就会指向正在被执行的指令。如果当前方法为本地方法，则PC的值为undefined。
- **执行引擎**
  - JVM的核心部分，负责执行程序的字节码文件。
  - 现代虚拟机都会搭载即时编译技术，将方法编译为字节码的方式，提高执行效率。

#### 1.2 常用JVM参数

- 输出GC日志
  - 1.9之前
    - `-XX:+PrintGC`，输出所有GC日志
    - `-XX:+PrintGCDetails`，输出所有GC详细日志
  - 1.9之后
    - `-Xlog:gc`，输出所有GC日志
    - `-Xlog:gc*`，输出所有GC详细日志
- 类加载&卸载
  - `-verbose:class`，输出类的加载和卸载信息
  - `-XX:+TraceClassLoading`，输出类的加载信息（1.9以后，`-Xlog:class+load=info`）
  - `-XX:+TraceClassUnloading`，输出类的卸载信息（1.9以后，`-Xlog:class+unload=info`）
- 堆参数
  - `-Xms`，初始堆大小
  - `-Xmx`，最大堆大小
  - 一般可以通过**将初始堆和最大堆设置为相同，减少程序运行时垃圾回收的次数，提高程序性能**。
- 新生代参数
  - `-Xmn`，设置新生代大小，新生代过大会导致老年代减小
  - `-XSurvivorRatio=`，设置新生代中eden区和from/to区的比例
  - **一般新生代占整个堆空间的1/3到1/4**。
  - 新生代大小的设置，应当根据具体情况配置，但基本策略是**尽可能将对象留在新生代，减少老生代的GC次数**。
- 新老生代参数
  - `-XXNewRatio=`，设置堆内老生代和新生代的比例
- 工作模式
  - `-client`，启动速度快、针对运行时间不长的、追求启动速度的程序
  - `-server`，启动速度慢，但运行稳定后，执行速度会快很多（有更多更好的优化算法）
- 输出所有配置参数
  - `-XX:+PrintFlagsFinal`，输出所有JVM配置参数。



### 2. 内容

#### 2.1 类加载

##### 2.1.1 类的加载

- 当程序主动使用某个类时，如果该类未在内存中加载，则JVM会通过三步对类进行加载

  - **Load**，将类的class文件读入内存，并创建一个Class对象（类加载器完成该操作）；

  - **Link**，将类的二进制数据合并到JRE中；

    - 验证，**字节码校验**，确保加载的类信息复合JVM规范；
    - 准备，正式为**类变量分配内存并设置初始值**，这些内存都在**方法区**中分配；
    - 解析，虚拟机常量池内的符号引用（常量名）替换为直接引用（地址），指**带static final修饰的属性**。

  - **Initialize**，JVM负责对类进行初始化。

    - 初始化，即执行类构造器\<clinit>()方法的过程。
    - 该方法是由编译期自动收集类中所有类变量的赋值动作和静态代码块合并产生的，**类变量赋值和静态代码块的顺序只和在源码文件中的编写顺序相关**。
    - **但初始化一个类时，若其父类尚未初始化，则会先触发父类的初始化**。

    - **该初始化过程由JVM保证了正确加锁和同步**。
    - 这个地方可以实现独特的单例模式，JVM层保证单例并发安全。

    ```java
    public class Singleton{
        private Singleton(){}
        
        static class SingletonHolder{
            private static final Singleton instance = new Singleton();
        }
        
        public Singleton getInstance(){
            return SingletonHolder.instance;
        }
    }
    ```

- 主动引用和被动引用，主动引用，被动引用不会触发类的初始化

  - 主动引用一定会触发类的初始化
    - main方法所在类；
    - new一个类的对象；
    - **调用类的非父类、非final静态成员或者静态方法**；
    - 通过反射包`java.lang.reflect`的方法对类反射调用；
    - 子类初始化时父类未初始化，父类初始化。
  - 被动引用不会触发初始化
    - **子类引用父类的静态变量时，只会初始化父类**；
    - **引用类的常量(final static)时，类不会加载**；
    - **声明数组(`Object[] objs = new Object[2]`)时，类不会加载**。

##### 2.1.2 ClassLoader

- 类加载，将class文件字节码内容加载到内存中，并将这些静态数据转换到方法区的运行时数据结构，然后在堆中生成唯一的一个Class对象。
- 类缓存，标准的类加载器可以按照要求查找类，但**一旦某个类被加载到类加载器中，该Class对象将维持一段时间，不过垃圾回收机制可以回收这些对象**。
- JVM规定了以下类加载器
  - 引导类加载器，C++编写，JVM自带的类加载器`BootstrapClassLoader`，负责Java核心库(rt.jar)。
  - 扩展类加载器`ExtClassLoader`，负责`jre/lib/ext`目录下的，或者`-D java.ext.dirs`指定目录下的jar包的加载。
  - 系统类加载器`AppClassLoader`，负责`java -classpath`或`-D java.class.path`所指向的目录下的jar包的加载。
    - 通过`ClassLoader.getSystemClassLoader()`获取到的类加载器为该加载器
    - `getParent()`获取父类类加载器，不断向上获取，但引导类加载器作为非Java编写的加载器，因此获取到的为null。
  - 自定义加载器。

##### 2.1.3 双亲委派机制

- 双亲委派机制指的是JVM中的类加载机制，为的是
  - **防止重复加载同一个类**。
  - **防止核心类（例如java.lang.String等）被篡改，保证数据安全**。
- **当类加载器需要加载某一个类（即加载.class文件时），会首先将加载任务委托给上级加载器，如果上级加载器未成功加载，再有自己加载该类**。
- 委托顺序为`自定义加载器 -> 系统类加载器AppClassLoader -> 扩展类加载器ExtClassLoader -> 引导类加载器BootstrapClassLoader`。



#### 2.2 Native方法

- **线程共享**。

- Java语言本身已经无法完成任务，需要使用更底层的方法来实现（C/C++），将类中的方法添加native关键字，然后交给底层实现。
- `public native void test0();`
- 通过JNI(Java Native Inteface)实现Java调用C/C++程序方法。
- **也是这个理由导致Java其实存在一定的平台问题，可能会有平台不同导致的本地native库实现不同**。



#### 2.3 程序计数器

- PC（Program Counter），**线程私有**。



#### 2.4 方法区

- **线程共享**，用于保存系统的类信息，比如类的Class信息、常量池等。**方法区的大小决定了系统可以保存多少个类。若加载的类过多，会导致方法区溢出，虚拟机会抛出OOM错误**。
- 方法区在1.8之前的实现为**永久区**，可以通过`-XX:PermSize`和`-XX:MaxPermSize`指定大小，默认MaxPermSize为64M。
- 在1.8之后永久区被彻底移除，取而代之的是**元数据区**，可以通过`-XX:MaxMetaspaceSize=`指定，这是一块**堆外直接内存，没有默认大小，如果不指定大小，则会耗尽系统的可用内存**。



#### 2.5 栈内存

- **线程私有**，该内存区域与线程的执行密切相关，线程的基本行为即函数调用，每次函数调用的参数传递是通过栈内存传递的。
- 栈内存只提供了入栈和出栈方法。
  - 每一次函数调用，就会有一个栈帧入栈。
  - 当函数正常返回或是抛出异常返回，就会有一个栈帧出栈。
- 在一个栈帧中，至少包括**局部变量表、操作数栈、帧数据区**几部分。
  - **局部变量表**，用于保存函数参数列表、局部变量信息。
    - 该表过大会导致栈帧内存增大，减少可用栈帧总数。
    - **局部变量表中的变量也是垃圾回收的关键参考点，被局部变量表直接或间接引用的对象是不会被回收的**。
  - 操作数栈，主要用于保存计算过程中的临时结果。
  - 帧数据区，主要用于支持常量池解析（常量池指针）、正常方法返回和异常处理。
- 栈深度是有限的，当线程的运行栈深度超过了最大可用栈深度时，就会抛出栈溢出错误StackOverflowError。
  - 该部分可以通过JVM参数`-Xss256K`来指定。



#### 2.6 堆内存

- **线程共享**，每一个JVM实例只有一个堆内存。

- **分为新生代、老生代**
  - 新生代，存放年轻对象的堆空间，年轻对象指刚刚创建的或者经历GC次数不多的对象。
  - 老生代，存放老年对象的堆空间，老年对象指经历多次GC后依次存活的对象。
  
- 新生代，内部又分为几个部分

  - eden区，一般新对象的内存创建位置，内部大部分对象都会在一次GC中被回收
  - survivor区，当eden区的对象经过一次GC后，依旧存活，就会进入survivor区
    - survivor区又被分为完全等价的两块内存区域from/to区。**为的是通过内存复制策略，解决内存连续性和内存空间浪费的问题**
  - **一般情况下eden区 : from区 : to区 = 8 : 1 : 1**。
  - 新生代的GC，又称Young GC，Minor GC，**时间消耗较短、频度高**，使用的基本上是内存复制策略。

- 老生代

  - 什么情况下会晋升到老年代？
    - **当新生代中经过一定次数GC（该次数可以通过该参数配置，值只能在0-15(4bit)之间，`-XX:MaxTenuringThreshold=15`），会进入到老生代中**
    - eden区满了，存在对象在从eden或是from区复制到to区时，内存不足以复制。则直接进入老年区
    - **动态年龄判断**，当survivor区中的相同年龄的对象所占的内存大小超过了整个空间的一半，则全员进入老年代，无需大于gc年龄阈值。
  - 老生代的GC，又称Full GC，Major GC，**时间消耗较长、频度低**，使用的基本上是标签清除或是标签压缩策略。

  



#### 2.7 直接内存

- Java的NIO库能使用直接内存，**该内存区域是在堆外，直接向系统申请的内存区域**，访问速度一般优于堆内存。
- 直接内存的大小问题
  - 直接内存存在最大可用直接内存，可以通过`-XX:MaxDirectMemorySize=`来配置，若不配置则默认为`-Xmx`的值，即最大可用堆内存的值。**该值意味着一次可申请的直接内存最大值**。
  - **当直接内存使用量达到了最大值，会进行一次GC，完成后如果空间依旧不足够则会抛出OOM错误。**
  - **直接内存的总大小依旧受到操作系统本身最大内存的影响**。



#### 2.8 直接内存与堆内存差异

- 直接内存在空间申请上，会比申请堆内存慢。
- 但使用直接内存做高频度的IO操作时，会比经由堆内存的IO快很多（在Server模式下更明显）。
- **直接内存适用于申请次数少、访问较频繁的场景**。



#### 2.9 常量池

- 该区域专门用于存放字符串常量，**在jdk7之前，该部分为永生区的一部分，jdk7之后，被移动到了堆中管理**。

- 可以通过String的实例方法`intern()`获得常量池中的字符串引用（若池中没有该字符串，则会添加到池中）。

- 值得注意的是`intern()`**返回的值一定等于字符串常量，但并不代表字符串常量在内存中的位置就一定不会变化了**。由于GC的关系，有可能出现前一步调用了intern加入字符串常量后，就被GC回收，再调用intern加入字符串常量时就是新的内存区域了。

  ```java
  String s1 = "QK";
  System.out.println(System.identityHashCode(s1 + "0"));
  System.out.println(System.identityHashCode((s1 + "0").intern()));
  System.gc();
  System.out.println(System.identityHashCode((s1 + "0").intern()));
  // 1160460865
  // 1247233941
  // 258952499
  ```

  



### 3. 垃圾回收策略

- JVM的垃圾回收基本策略：**分代算法**
  - **新生代中90%的对象很快就会被回收，因此更适用于内存复制**。
    - 新生代中的对象经过几次GC后依旧存活，就会移动到老生代。
  - **老生代中大部分对象都是会常驻内存的、因此一般采用标记压缩或者标记清除**。
    - 极端情况下，老生代的存活率可能为100%。



#### 3.1 引用计数法

- 最老式的垃圾回收方法，思路和实现简单。
- 核心思想是只要有对象引用了A，则A的引用计数器加一，失去引用后，引用计数器减一，只要引用计数器为0，则认为可以回收A。
- 该方案存在致命问题：
  - 无法处理循环引用（不可达对象之间循环引用）；
  - 引用计数器要求每次引用产生或是失去时，会有加法和减法操作，会影响系统性能。
- JVM从未采用该方案做垃圾回收。



#### 3.2 标记清除法

- **标记清除法是现代垃圾回收方法的思想基础**。
  - 可达对象：通过根节点开始引用搜索，最终可以达到的对象
  - 不可达对象：通过根节点开始引用搜索，最终不可以达到的对象

- 标记清除法分为两个阶段，标记阶段和清除阶段。
  - 标记阶段，通过根节点标记所有从根节点开始的可达对象，所有未被标记的对象既是垃圾对象。
  - 清除阶段，清除掉所有未被标记的对象。
- 该方案存在一个问题
  - **会产生内存空间碎片，不利于以后大对象的分配（不连续空间的分配效率会低于连续空间）**。



#### 3.3 内存复制

- 复制算法的核心是，**将原有的内存分为两块，每次只是用其中一块，在进行垃圾回收时，将正在使用的内存中的存活对象赋值到未使用的内存块中，之后清除正在使用的内存块中的垃圾对象，并交换两块内存之间的角色**。
- 单纯的内存复制能带来
  - 真正需要垃圾回收时，复制算法的效率会非常高，因为垃圾对象多余存活对象。
  - 同时新的内存区域中内存空间是连续的，没有碎片的。
  - 但**代价就是系统的内存折半了**。

- JVM自身的解决方案
  - **新生代区分为eden区和survivor区，survivor区中又分为大小相等、地位相等且可以进行角色互换的from区和to区**。
  - 一次GC时，
    - 将eden区的存活对象复制到未使用的survivor区，假设为to区（可能是to区也可能是from区）
    - 将正在使用的survivor区（from区）的年轻对象复制到to区，**老对象或者to区已满则直接进入老年区**。
    - 在eden区和from区的剩余对象就是垃圾对象。
  - **该复制策略即保证了内存空间的连续性、又解决了大量的内存空间浪费问题。**
  - **但只适用于新生代区这类存活对象相较垃圾对象更少的场景**。
  - **一般情况下eden区 : from区 : to区 = 8 : 1 : 1**。



#### 3.4 标记压缩

- 对于存活对象相较垃圾对象更多的老年代区，内存复制策略并不适用，采用的是标记压缩策略。
- 该策略在标记清除的基础上做优化
  - **从根节点开始对所有可达节点做一次标记**
  - **将所有存活对象压缩到内存的一端**
  - **清理其他的所有空间**
- **该策略能有效避免内存碎片产生、同时不需要两块内存区域**。



#### 3.5 卡表（Card Table）

- 卡表的引入是为了提升新生代GC的效率，通过记录一个比特位集合的数据结构，即卡表，实现**记录老年代某一区域中的所有对象是否持有新生代对象的引用**。这样新生代GC时，就不需要扫描整个老生代区来确定引用关系。
- 例如，**卡表中每一比特位对应4KB老年代空间，值位0则表示该空间不含有对新生代的引用，为1则表示该控件含有对新生代的引用**。



#### 3.6 分区算法

- 将整个堆空间划分为连续的小区间，每一个小区间都独立使用，独立回收。
- **在相同条件下，堆空间越大，一次GC所需要的时间就越长，从而产生的停顿也就越长**。
- 通过合理安排回收若干个内存小区间，能有效减少一次GC所产生的停顿。



### 4. 垃圾判定策略

#### 4.1 可触及性

- 垃圾回收的基本思想是考查每一个对象的可触及性，即从根节点开始能否访问到这个对象。**根据实际情况对象可被分为以下三种状态**。
  - **可触及**：从根节点能访问到，表示该对象正在被使用
  - **可复活**：对象的所有引用都被释放，但对象可能在finalize()方法后复活
  - **不可触及**：finalize()方法后未复活（该方法只会调用一次），则会进入不可触及状态



#### 4.2 对象的复活

- finalize()方法继承自Object类，通过**重写该方法可能会导致对象复活的情况**，因为该方法会有this引用传入，如果this引用外泄，则会导致对象转变为可触及状态。
- 不推荐使用finalize方法做资源释放的操作
  - 可能引起对象复活
  - 该方法为系统调用，调用时间不由用户指定



#### 4.3 强软弱虚引用类型

- **强引用**

  - 最常见的引用方式，通常创建的对象都是强引用。
  - 当一个对象被一个以上的强引用变量引用时，该对象处于可达状态，系统不会回收该对象资源。
  - **Java的内存泄漏一般就是由于，即使有些对象不再回用到，JVM也并不会回收被强引用变量引用的对象**。

- **软引用**

  - 软引用需要使用`SoftReference`类来实现。
  - **当一个对象只具有软引用时，它可能会被GC。当内存充足时，系统不会GC，当内存空间不足时，系统就会GC该对象**。

  ```java
  // new SoftReference(T obj)
  SoftReference<String> softStr = new SoftReference<String>(new String("123"));
  ```

- **弱引用**

  - 弱引用类似于软引用，但生存期更短，弱引用通过`WeakReference`类实现。
  - **当一个对象只具有弱引用时，当GC运行时，该对象就会被发现就立即回收。核心在于GC运行时该对象被发现，不代表当一个对象只有弱引用时就会被回收**。

  ```java
  // new WeakReference(T obj)
  WeakReference<String> weakStr = new WeakReference<String>(new String("123"));
  
  // 输出123
  System.out.println(weakStr.get());
  System.gc();
  System.runFinalization();
  // 输出null
  System.out.println(weakStr.get());
  ```

- **虚引用**

  - 虚引用随时可能被GC回收，当试图通过get()方法取得强引用时，总会失败，**并且必须和引用队列一起使用**。
  - **虚引用的作用在于跟踪GC回收过程**。
  - **如果GC准备回收一个对象时，发现还有虚引用，则会在回收后，将这个虚引用添加到引用队列中。**

  ```java
  // new PhantomReference(T obj, ReferenceQueue queue)
  // 同属于java.lang.ref包，表示引用队列
  ReferenceQueue<T> queue = new ReferenceQueue<T>();
  
  PhantomReference<T> ref = new PhantomReference<T>(new String("123"), queue);
  ```

  



### 5. *垃圾回收的停顿

#### 5.1 STW(Stop-the-world)

- **垃圾回收器的核心功能是垃圾的识别和回收**，为了高效地识别、清理垃圾，整个系统需要进入一个停顿的状态，即终止其他应用线程的运行。
  - 保证不会有新的垃圾产生
  - 保证系统某一瞬间的数据一致性
  - 方便垃圾回收器更好地回收垃圾
- 停顿产生时，整个应用程序会卡死，完全无响应。



#### 5.2 







### 6. 堆内存分析

#### 6.1 OOM问题

- OOM问题可能由于堆溢出、直接内存溢出、栈溢出、永久区溢出等，**最常见的还是堆内存溢出**。

- **堆内存溢出问题**，基本来源于大量对象占据堆空间，且无法被GC回收，导致超出了设置的最大堆大小。

- **直接内存溢出问题**，由于直接内存为堆外内存，不会被完全管理，因此使用不当（最大可用直接内存设置过大）可能导致内存溢出。

- **线程过多溢出问题**，由于同时创建的线程过多，由于线程栈内存在堆外，不会被完全管理，因此会导致内存溢出。可以通过减小堆内存大小`-Xmx`或是减小线程栈空间`-Xss`来增大同时可创建的线程数。

- **永生代/元空间(jdk8)溢出问题**，系统装载了过多的类信息，同时没有合理设置永生代/元空间的大小（`-XX:MaxPermSize`或`-XX:MaxMetaspaceSize`）

- **GC低效率引起的OOM**，JVM会评估GC的效率，当效率过低时，就会直接抛出OOM错误。判定规则如下

  - 花在GC上的时间是否超过了98%
  - 老年代释放的内存是否小于2%
  - eden区释放的内存是否小于2%
  - 是否连续5次GC都同时出现上述几种情况

  只有满足所有条件，JVM才会抛出OOM错误。可以通过`-XX:-UseGCOverheadLimit=false`来关闭。



### 7. *锁与并发

#### 7.1 锁在JVM中的实现和优化

- 在并发程序中，线程之间的竞争是不可避免的。如果**将所有线程竞争交给操作系统，必定会导致效率降低，因此在JVM这一层会在挂起线程之前，在虚拟机层面解决竞争关系，尽可能避免真实的竞争情况发生**。

##### 7.1.1 偏向锁

- 







### 8. *class文件结构

- .class文件是JVM的基石，任何语言只要能编译为标准class文件，就能在JVM上运行。
- .class文件使用一种**类似于C结构体**的形式描述，统一使用无符号数作为基本数据类型，由u1，u2，u4，u8分别表示1字节、2字节、4字节和8字节整数，对于字符串，使用u1数组表示。

```java
ClassFile{
    u4				magic;
    u2				minor_version;
    u2				major_version;
    u2				constant_pool_count;
    cp_info			constant_poo[constant_pool_count - 1];
    u2				access_flags;
    u2				this_class;
    u2				super_class;
    u2				interfaces_count;
    u2				interfaces[interfaces_count];
    u2				fields_count;
    field_info		fields[fields_count];
    u2				methods_count;
    method_info		methods[methods_count];
    u2				attributes_count;
    attribute_info	attributes[attributes_count]
}
```

#### 8.1 Magic魔数

- 魔数作为.class文件的标志，用来标志class文件，为一个**4bytes的无符号整数，恒定为`0xCAFEBABE`**。
- 如果.class文件头魔数不匹配，JVM则会在文件校验时抛错误



#### 8.2 class文件的版本

- 魔数之后通过2+2，总共4bytes，用以表明该.class是由什么版本的编译器编译的，前2bytes为小版本，后2bytes为大版本。
- 一般小版本值默认为0，**大版本值52（0x0034）表示jdk8的编译器**（数值根据版本号递增、递减，例如jdk7为51）。
- **高版本虚拟机可以执行低版本.class文件，但低版本虚拟机执行高版本.class文件会抛出错误**。



#### 8.3 





### 